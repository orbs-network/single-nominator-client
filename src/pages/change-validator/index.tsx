/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  AddressDisplay,
  Button,
  Input,
  ModalErrorContent,
  Page,
  Stepper,
  TxSuccess,
} from "components";
import { ColumnFlex, SubmitButton, Typography } from "styles";
import { useForm, Controller } from "react-hook-form";
import { isTonAddress, parseFormInputError } from "utils";
import { useChangeValidatorTx, useRoles, useVerifySNAddress } from "hooks";
import { useTonAddress } from "@tonconnect/ui-react";
import styled from "styled-components";
import { useCallback, useMemo } from "react";
import { useStore } from "./store";
import { useNavigate } from "react-router-dom";
import { ZERO_ADDR } from "consts";
import { Modal } from "antd";
import { isEqualAddresses } from "helpers/util";

const snInput = {
  label: "",
  name: "snAddress",
  validate: isTonAddress,
  error: "Invalid address",
  required: true,
  info: "The address of the single-nominator contract that you want to manage. Your wallet address must be the Owner / admin for this single-nominator.",
};

const newValidatorAddress = {
  label: "New validator address",
  name: "newValidatorAddress",
  validate: isTonAddress,
  error: "Invalid address",
  required: true,
  info: "The new updated address of the validator node that stakes the funds in the single-nominator. This address is normally generated by MyTonCtrl.",
};

const SnAddress = () => {
  const { setFromValues, nextStep, snAddress } = useStore();
  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<any>({
    mode: "onSubmit",
    reValidateMode: "onChange",
    defaultValues: {
      snAddress,
    },
  });
  const { mutateAsync, isLoading } = useVerifySNAddress();
  const onSubmit = async (data: { snAddress: string }) => {
   try {
     await mutateAsync({ snAddress: data.snAddress });
   } catch (error) {
    Modal.error({
      title: "Error",
      content: <ModalErrorContent message='Not a valid single nominator address' />,
    })
    return 
   }

    setFromValues({
      snAddress: data.snAddress,
    });
    nextStep();
  };

  return (
    <Stepper.Step>
      <Stepper.StepTitle>Enter single nominator address</Stepper.StepTitle>
      <form
        onSubmit={handleSubmit((data) =>
          onSubmit(data as { snAddress: string })
        )}
      >
        <ColumnFlex $noGap>
          <Controller
            name={snInput.name}
            control={control}
            key={snInput.name}
            rules={{ required: snInput.required, validate: snInput.validate }}
            render={({ field }) => {
              const errorMsg = parseFormInputError(
                errors[snInput.name]?.type,
                snInput.error
              );
              return (
                <Input
                  label={snInput.label}
                  field={field}
                  error={errorMsg}
                  info={snInput.info}
                />
              );
            }}
          />
          <SubmitButton connectionRequired type="submit" isLoading={isLoading}>
            Next
          </SubmitButton>
        </ColumnFlex>
      </form>
    </Stepper.Step>
  );
};

const Roles = () => {
  const { snAddress, nextStep, prevStep } = useStore();
  const tonAddress = useTonAddress();

  const { data: roles, isLoading } = useRoles(snAddress);
  const owner = roles?.owner;

  const invalidOnwer = useMemo(() => {
    if(!owner) return false
    return !isEqualAddresses(owner, tonAddress);
  }, [tonAddress, owner]);
  

  return (
    <Stepper.Step>
      <Stepper.StepTitle>Roles</Stepper.StepTitle>
      <ColumnFlex $gap={30}>
        <>
          <AddressDisplay
            isLoading={isLoading}
            title="Owner address"
            address={roles?.owner}
          />
          <AddressDisplay
            isLoading={isLoading}
            title="Validator address"
            address={roles?.validatorAddress}
          />
          {invalidOnwer && <Error />}
        </>
      </ColumnFlex>
      {invalidOnwer ? (
        <SubmitButton onClick={prevStep}>Back</SubmitButton>
      ) : (
        <SubmitButton
          onClick={nextStep}
          connectionRequired
          disabled={isLoading}
        >
          Next
        </SubmitButton>
      )}
    </Stepper.Step>
  );
};

const NewValidatorAddress = () => {
  const { setFromValues, nextStep, snAddress } = useStore();
  const { mutate, isLoading } = useChangeValidatorTx();
  const { data } = useRoles(snAddress);

  const {
    control,
    handleSubmit,
    formState: { errors },
    watch,
  } = useForm({
    mode: "onSubmit",
    reValidateMode: "onChange",
  });

  const address = watch("newValidatorAddress");

  const error = useCallback(() => {
    Modal.error({
      title: "Change validator address failed",
      content: <ModalErrorContent />,
    });
  }, []);

  const onSubmit = ({
    newValidatorAddress,
  }: {
    newValidatorAddress: string;
  }) => {


    if (isEqualAddresses(newValidatorAddress, data!.validatorAddress!)) {
      Modal.error({
        title: "Error",
        content: (
          <ModalErrorContent message="New validator address is the same as the old one" />
        ),
      });
      return;
    }
      setFromValues({
        newValidatorAddress,
      });
    mutate({
      address: snAddress,
      newAddress: newValidatorAddress,
      oldValidatorAddress: data!.validatorAddress!,
      onSuccess: nextStep,
      onError: error,
    });
  };

  return (
    <Stepper.Step>
      <Stepper.StepTitle>Enter new validator address</Stepper.StepTitle>
      <form
        onSubmit={handleSubmit((data) =>
          onSubmit(data as { newValidatorAddress: string })
        )}
      >
        <ColumnFlex $noGap>
          <Controller
            name={newValidatorAddress.name}
            control={control}
            key={newValidatorAddress.name}
            rules={{
              required: newValidatorAddress.required,
              validate: newValidatorAddress.validate,
            }}
            render={({ field }) => {
              const errorMsg = parseFormInputError(
                errors[newValidatorAddress.name]?.type,
                newValidatorAddress.error
              );
              return (
                <Input
                  label={newValidatorAddress.label}
                  field={field}
                  error={errorMsg}
                  info={newValidatorAddress.info}
                  button={
                    !address && (
                      <StyledZeroButton
                        type="button"
                        onClick={() => field.onChange(ZERO_ADDR)}
                      >
                        Zero Address
                      </StyledZeroButton>
                    )
                  }
                />
              );
            }}
          />
          <SubmitButton connectionRequired type="submit" isLoading={isLoading}>
            Set validator
          </SubmitButton>
        </ColumnFlex>
      </form>
    </Stepper.Step>
  );
};

const StyledZeroButton = styled.button``;

const Success = () => {
  const navigate = useNavigate();
  const { reset } = useStore();
  return (
    <Stepper.Step>
      <TxSuccess
        button={
          <Button
            onClick={() => {
              navigate("/");
              reset();
            }}
          >
            Home
          </Button>
        }
        text='Validator address has been changed successfully'
      />
    </Stepper.Step>
  );
};

const steps = [
  {
    title: "Enter single nominator address",
    component: <SnAddress />,
  },
  {
    title: "Read roles",
    component: <Roles />,
  },
  {
    title: "Set new validator address",
    component: <NewValidatorAddress />,
  },
  {
    title: "",
    component: <Success />,
  },
];

function ChangeValidatorPage() {
  const { setStep, step } = useStore();

  return (
    <Page title="Change Validator">
      <Stepper setStep={setStep} currentStep={step} steps={steps} />
    </Page>
  );
}

const Error = () => {
  return (
    <StyledError>
      Only the single nominator's owner can set the validator address
    </StyledError>
  );
};

const StyledError = styled(Typography)`
  color: red;
`;

export default ChangeValidatorPage;
